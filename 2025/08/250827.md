# TIL React 최적화 - 최적화 함수
## 최적화 함수 사용 이유
* 꼭 리렌더링 되지 않아도 되는 표시되는 내용이 바뀌지 않는 컴포넌트 리렌더링 될 때

* 처음 빈 페이지를 받아온 다음 자바스크립트를 통해서 화면을 그려주는  
리액트의 CSR 방식 때문에 첫 로딩이 너무 오래 걸린다고 느껴질 때  

> 두 가지 모두 리액트의 기본 작동방식에 의한 비효율  
 좀 더 빠르고 성능 좋은 애플리케이션 생성을 위한 최적화 함수 사용  
모든 최적화 함수는 함수형 컴포넌트가 함수라서 생겨남


### useMemo()
* 함수 호출 결과 저장
#### 역할
1. 만약 함수가 수행하는 연산이 더 복잡하고 오래 걸린다면 리렌더링 할때마다 비효율이 계속해서 누적
2. 그런 상황을 방지하기 위해서 함수가 전달받는 인자값이 변한다던가 하는 상황이 오지 않으면  
굳이 다시 함수를 호출하지 않고 이전에 호출했던 값을 저장해놓고 다시 사용
```
const numberPlus1 = useMemo(() => {
    return plus1(number);
  }, [rerender]);
```
1. 두가지 전달 인자를 받음(useEffect와 비슷) 
    * 첫번째 인자로 **함수**
    * 두번째 인자로 **배열** 

2. 호출한 결과로는 함수 코드가 리턴하는 호출 결과를 변수에 저장

3. 배열 안에 있는 값이 함수 실행 결과에 영향을 주는 값이 있다면  
함수 호출의 결과가 변하는 경우에만 함수를 다시 호출한다는 의미로 사용

### useCallback()
* 함수 자체를 저장
#### 역할
함수 컴포넌트를 호출하면 그 컴포넌트 내부에서 선언되고 할당되는 함수를 새롭게 만드는 과정이 진행되기 때문에  
함수가 새롭게 만들어지는 과정을 막기 위해 사용
```
const plus1 = useCallback((number) => {
    console.log("plus1 실행됨")
    return number + 1;
  }, []) 
```
1. 두가지 인자를 전달 받음
    * 첫번째 인자로 **함수**
    * 두번째 인자로 **배열**

2. 인자를 받아서 더해주는 함수 자체를 저장

3. 배열의 값이 변하지 않으면 함수를 다시 만들지 않음

### memo()
* 컴포넌트를 저장
```
const NumberDisplay = memo(({number}) => {
  console.log("Display 렌더링")
  return <div>numner: {number}</div>
});
```
1. 컴포넌트 자체 저장

2. 함수 호출 시 함수를 전달하는데 함수가 함수 컴포넌트가 됨
    * 함수 컴포넌트를 memo함수로 한번 감싸준다고 생각하면 됨

3. Memo로 감싸준 컴포넌트를 변수에 담아서 사용

4. Props의 값이 변하지 않으면 리렌더링 안함
    * Memo는 props가 동일한 경우에만 한정되어 리렌더링 방지해주는 역할

    * 만약 컴포넌트가 자기만의 상태를 가지고 사용한다면  
    그 상태가 변경 되면 props가 동일하더라도 리렌더링이 발생할 수 밖에 없음  
    (Memo가 전달받는 컴포넌트도 리액트의 기능을 사용할 수 있기 때문)
